# 3. 컴퓨터 시스템의 동작 원리





## 1. 컴퓨터 시스템의 구조

 컴퓨터 입장에서 보면 컴퓨터 업무의 처리 방식은 컴퓨터 외부 장치에서 컴퓨터 내부로 데이터를 읽어와서 각종 연산을 수행한 후 그 결과를 컴퓨터 외부 장치로 다시 내어 보내는 방식으로 진행됨(입출력)

 컴퓨터 내 하드웨어 장치에는 컨트롤러라는 것이 붙어있는데 컨트롤러는 일종의 작은 CPU로서, 컴퓨터 전체에 CPU라는 중앙 처리 장치가 있듯이 컨트롤러는 각 하드웨어 장치마다 존재하면서 이들을 제어하는 작은 CPU다. ex) 메모리 관리는 메모리 컨트롤러

 우리가 생각하는 운영체제는 여러가지 프로그램이 동시에 수행되는 시스템을 위한 운영체제이다. 운영 체제는 컴퓨터가 부팅되었을 떄부터 항상 수행되면서 각종 자원들을 관리해야 항상 메모리에 올라가 있다. 이 때 운영체제의 코든 코드를 다 메모리에 상주시키면 낭비가 심하기 때문에 운영체제 중 항상 메모리에 올라가 있는 부분은 운영체제의 일부이며, 이를 **커널** 이라고 부른다.



## 2. CPU와 I/O 연산

 컴퓨터가 연산을 한다는 것은 CPU가 무언가 일을 한다는 뜻이다.

입출력 장치들의 I/O 연산은 I/O 컨트롤러가 담당하고, 컴퓨터 내에서 수행되는 연산은 메인 CPU가 담당하게 된다. 이 떄 입출력 장치와 메인 CPU는 동시 수행이 가능하다.

 각 장치마다 이를 제어하기 위해 설치된 장치 컨트롤러에는 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리를 가지고 있다. 이를 로컬 버퍼라고 부른다.

![image](https://user-images.githubusercontent.com/68668924/112405605-f52c7480-8d55-11eb-992f-c438d7b8f748.png) 

디스크나 키보드 등에서 데이터를 읽어 오는 경우, 우선 로컬 버퍼에 데이터가 임시로 저장된 후 메모리에 전달된다. 이 때 장치에서 로컬 버퍼로 읽어오는 일은 컨트롤러가 담당한다.

예시) 프로그램 B가 수행중 디스크에서 데이터를 읽어오라는 명령을 내림

1. 디스크 컨트롤러가 물리적인 디스크에서 내용을 읽어 이를 로컬 버퍼에 저장한다.
2. 데이터를 모두 가지고 왔으면 컨트롤러가 인터럽트를 발생시켜 CPU에게 보고한다. // 인터럽트란 CPU의 서비스가 필요할때 이를 통보하는 방법
3. 기본적으로 CPU는 매 시점 메모리에서 명령을 하나씩 읽어와서 수행한다. 이 때 CPU 옆에는 인터럽트 라인이 있어서 CPU가 자신의 작업을 하던 중간에 인터럽트 라인에 신호가 들어오면 하던 일을 멈추고 인터럽트와 관련된 일을 처리한다.// CPU는 명령 하나를 수행할 때마다 인터럽트가 발생했는지를 체크한다.



## 3. 인터럽트의 일반적 기능

CPU는 인터럽트가 들어옴을 인지하면 인터럽트 관련 업무를 수행하게 된다. 운영 체제 커널에는 인터럽트가 들어왔을 떄 해야 할 일을 미리 프로그래밍해서 보관하고 있다. (운영 체제의 개발자가 운영체제가 해야할 일을 미리 프로그래밍해서 커널 내에 포함시켜두었는데 그중 한 가지가 인터럽트 처리 루틴)

**인터럽트 발생 시 CPU가 수행하는 구체적인 예**

 로컬 버퍼에 있는 내용을 프로그램 B가 사용할 수 있도록 메모리로 전달하고, 이제 B가 CPU를 할당받을 경우 다음 명령을 수행할 수 있음을 표시.



**인터럽트의 종류**

인터럽트에는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. CPU의 서비스가 필요한 경우, CPU 옆에 있는 인터럽트 라인에 신호를 보내어서 인터럽트가 발생했음을 알려주는 방식은 둘 다 동일함. 다만 하드웨어 인터럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅함 소프트웨어 인터럽트는 소프트웨어가 그 일을 수행함



**인터럽트가 들어오면?**

인터럽트가 들어왔을 때 CPU는 하던일을 멈추고 인터럽트를 처리하기 위한 루틴(운영체제 커널 내부 코드)에 들어가서 정의도니 일을 찾게된다. 운영 체제는 항 일을 쉽게 찾아가기 위해 인터럽트 벡터를 가지고 있다.

```인터럽트 벡터
인터럽트 벡터란?
 인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야 할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조
```

 실제 처리해야 할 내용은 인터럽트 서비스 루틴이라는 다른 곳에서 정의된다.



 인터럽트 서비스 루틴을 통해 해당 인터럽트 처리를 완료하고 나면 원래 수행하던 작업으로 돌아가 정지되었던 일을 계속해서 수행하게 된다. 인터럽트 처리 후에 되돌아갈 위치를 알기위해서 인터럽트 처리 전 수행하던 작업이 무엇이었는지 알기 위헤 운영체제는 별도로 가지고 있는 저장소에 저장해 놓는다.(스택에 저장)



## 4. 인터럽트 핸들링

 인터럽트 핸들링이란 인터럽트가 발생한 경우에 처리해야 할 일의 절차를 의미한다.

인터럽트는 함수 호출과 유사한 매커니즘으로 처리하게 된다.

 프로그램 A가 수행되고 있을 때 인터럽트 발생하면 A의 현재 상태를 저장하게 된다.(CPU가 수행중이던 메모리 주소를 포함한 부가적인 정보)



 **Process Control Block**
 CPU에서 명령이 수행될 때에는 CPU 내부에 있는 임시 기억 장치인 레지스터에 데이터를 읽어오거나 쓰면서 작업을 수행하게 되는데, 이 때 인터럽트가 발생해 새로운 명령을 수행하면 기존의 레지스터 값들이 지워지게 되므로 레지스터 값 등 CPU내의 하드웨어 상태를 저장해 두어야 한다. 이 것을 모두 저장한 후에나 인터럽트 처리가 이루어질 수 있다.
 운영 체제 커널 영역에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB)을 두고 있다. 그 자료 구조 중 일부분은 인터럽트가 발생했을 때 프로그램의 어느 부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다. 이 부분에 저장되는 내용으로는 현재 수행중이던 메모리 주소와 레지스터 값, 그리고 하드웨어 상태 등이 있다. 이러한 정보가 저장되었다 인터럽트 수행이 끝나면 저장된 값을 CPU 상에 다시 복원해 인터럽트 당하기 직전의 명령을 계속 수행할 수 있다.

 

 프로그램 내부의 함수 호출 시 그 복원 지점에 대한 정보는 각  프로그램의 주소 공간 중 스택 부분에 저장된다. 인터럽트 처리 루틴은 운영 체제 커널의 일부이고 커널 역시 함수 구조로 이루어져 있으므로 인터럽트 처리 코드가 수행되는 도중에도 함수 호출이 이루어질 수 있어 스택의 이용이 필요하다. 인터럽트의 처리는 커널의 코드를 수행하는 것이므로 인터럽트 처리 중 발생하는 함수 호출시에는 운영 체제 커널의 주소 공간 중 스택 영역을 사용한다.



**커널 스택**
 현재 수행중인 프로그램 수가 n 개라고 할 때 커널 스택은 현재 수행중인 프로그램 개수인 n 만큼 독립적인 공간을 둔다. 즉 인터럽트 처리 루틴으로 넘어와서 함수 호출이 이루어질 경우 각 프로세스별로 독자적인 커널 스택을 사용하게 된다.



**과정**

인터럽트 발생 -> 현재까지 수행된 지점을 프로세스 제어 블록에 저장, 인터럽트 처리루틴 으로 이동 -> 커널 코드를 수행하게 되며, 이 떄 이루어지는 함수 호출은 프로세스 A의 커널 스택을 사용하게됨 -> 인터럽트 마치면 PCB에 저장된 주소로 돌아가서 다시 수행



**인터럽트 처리 중 또 다른 인터럽트가 발생하면?**

 원칙적으로 인터럽트 처리중에 또 다른 인터럽트가 발생하는 것을 허용하지 않음(데이터의 일관성이 유지되지 않는 경우가 발생하기 때문)

  시급하거나 CPU를 당장 사용해야 하는 일이 발생하면?

=> 인터럽트마다 중요도가 다르며, 우선순위 높은 인터럽트 발생 시 현재 처리중이던 인터럽트 코드 수행 지점을 커널 스택에 저장하고 우선순위가 높은 인터럽트를 처리하게 된다. 인터럽트 처리가 마쳐지면 커널 스택에서 저장된 주소로 복귀해 이전에 수행하던 인터럽트 처리 코드를 마저 수행함





**소프트웨어 인터럽트**

 통상적 인터럽트는 하드웨어 인터럽트를 의미하고, 소프트웨어 인터럽트는 **트랩** 이라는 용여러 주로 불림

소프트웨어 인터럽트의 예로는 **예외상황**, **시스템 콜** 등이 있음.



**예외사항이란?**

- 프로세스가 0으로 나누는 등 불가능한 작업을 시도
- 자신의 메모리 영역 바깥을 접근하려는 시도

위와 같은 시도등을 할 떄 이에 대하 처리를 위해 발생시키는 인터럽트를 말함



소프트웨어 인터럽트는 하드웨어 인터럽트처럼 컨트롤러가 발생시키는 인터럽트가 아니라 프로그램 수행 도중 직접 CPU에 인터럽트 라인을 세팅하여 밠애시킴









## 5. 입출력 구조

입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데이터를 주고 받는 것을 말한다. 입출력 방식에는 동기식 입출력과 비동기식 입출력이 있다.



- 동기식 입출력

   입출력 요청후 입출력 작업이 완료된 후에야 CPU의 제어권이 그 프로그램에게 다시 넘어갈 수 있는 방식을 말함. ( 입출이 진행되는동안 다음 명령을 수행하지 않고 기다리게 된다.)

  동기식 입출력을 요청한 프로그램은 입출력이 완료될 떄까지 다음 명령을 수행할 수 없기 때문에 그동안 CPU가 낭비된다. 이 경우 낭비가 심하기 때문에 CPU의 효율적인 사용을 위해 입출력이 수행되는 동안 현재 프로그램은 봉쇄상태로 만들고 다른 프로그램에게 CPU를 양도하면서 동시에 다수의 입출력 연산이 일어날 수 있다. 이때 오류가 유발될 수 있기 때물에 동기성을 보장하기 위해 장치마다 큐를 두어 요청된 수넛대로 처리할 수 있도록 한다.

  ```봉쇄 상태란?
  봉쇄상태란
   입출력이 완료될 때까지 그 프로그램에 CPU를 할당하더라도 명령을 수행하지 못하기 때문에 봉쇄상태로 전환하는것. 
   이후 CPU를 할당하면 곧바로 작업을 수행할 수 있는 비 봉쇄 프로그램들에게만 CPU를 할당한다.
  ```

  

   연산 완료 시 완료 통보는 인터럽트를 통해서 수행하며, 이 경우 운영 체제 커널은 인터럽트 처리 루틴으로 가서 입출력 연산을 끝낸 프로그램이 CPU를 할당받을 수 있도록 봉쇄 상태로부터 해제시킨다. 

- 비동기식 입출력

   연산 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식

  ex) 어떤 프로그램이 데이터를 디스크에서 읽어오라는 요청 했을때 보통 읽어온 결과를 이용해서 다음 연산을 수행하지만 경우에 따라서는 그 데이터와 관련없이 수행할 수 있는 일이 있을 수 있음. 비동기식 입출력에서는 그러한 작업을 먼저 수행하고 읽어오는 데이터가 반드시 있어야 수행할 수 있는 일들은 입출력이 완료된 후에 수행하게 된다. 또한 입출력 요청이 디스크에서 읽어오는 요청이 아니라 쓰는 요청이라면 쓰기 작업이 완료되기 전에도 다음 명령을 수행할 수 있으므로 비동기식 입출력이 사용될 수 있음

일반적으로 입출력 요청을 운영체제에게 하게 되면 해당 프로그램이 입출력이 완료될 떄까지 그 프로그램을 봉쇄시키는 동기식 입출력을 사용함.



## 6. DMA(Direct Memoery Access)

 원칙적으로 메모리는 CPU에 의해서만 접근 가능한 장치이다. 따라서 주변 장치들이 메모리에 접근하기 위해서는 CPU에게 인터럽트를 발생시켜 CPU가 일을 대행하는 식으로만 가능하다.

컨트롤러가 CPU에게 인터럽트를 발생시키면 CPU는 컨트롤러의 로컬 버퍼와 메모리 사이에서 데이터를 옮겨 주는 일일 하게된다. 한편 모든 메모리 접근 연산이 CPU에 의해서만 이루어질 경우 주변 장치가 메모리 접근을 원할 떄마다 인터럽트를 통해 CPU의 업무 방해를 받게 되어 CPU 사용의 효율성이 떨어지는 문제점이 발생한다.

 위와 같은 상황을 극복하기 위해 메모리 접근이 가능한 장치를 하나 더 두는데 이와 같은 장치를 DMA라고 부른다 DMA는 일종의 컨트롤러로서 CPU가 주변 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주는 역할을 한다.

DMA를 사용하게 되면 로컬 버퍼에서 메모리로 읽어오는 작업을 CPU가 담당하는 것이 아니라 DMA가 대행함으로써 CPU는 원래 하던 작업을 멈추고 인터럽트를 처리할 필요가 없어진다.

이 떄 DMA는 바이트 단위가 아니라 블록이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시켜서 해당 작업의 완료를 알려 주게 된다. (CPU에 발생하는 인터럽트 빈도를 줄여주는 것)



## 7. 저장장치 구조

컴퓨터 시스템을 구성하는 저장 장치는 주 기억 장치와 보조 기억 장치로 나누어 볼 수 있습니다.

- 주 기억 장치

  보통 메모리라고 부르며 전원이 나가면 저장되었던 내용이 모두 사라져 버리는 휘발성의 RAM을 매체로 사용하는 경우가 대부분이다.

- 보조 기억 장치

  전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성 마그네틱 디스크를 흔히 사용함. 



보조기억 장치의 용도는 크게 두 가지로 구분된다.

1. 파일 시스템 용, 전원이 나가도 유지해야할 정보가 있으면 그것을 파일 형태로 보조 기억 장치에 저장하게 됨
2. 메모리의 연장공간인 스왑 영역 용 (운영체제는 당장 피룡한 부분만 메모리에 올려놓고 나머지는 스왑 영역에 내려놓음, 디스크에 내려놓는 일을 스왑 아웃 시킨다고 말하며, 스왑 아웃된 부분이 필요할 떄에는 다시 메모리 영역으로 올라가게 된다.)



## 8. 저장 장치의 계층 구조

 컴퓨터 시스템을 구성하는 저장 장치는 빠른 저장장치부터 느린 저장 장치까지 단계적인 계층구조로 이루어진다.

캐시 메모리는 캐슁기법을 사용해서 적은 용량의 캐쉬메모리로도 메인 메모리와 같이 큰 용량을 가진 것 처럼 효율적으로 동작하도록 관리할 수 있음

 => 반복되는 경우를 빠른 저장장치에 올려놓기



## 9. 하드웨어 보안

하드웨어 보안을 유지하기 위해 운영 체제는 기본적으로 두 가지 모드의 오퍼레이션을 지원한다. 커널모드와 사용자 모드 이에 해당한다.



- 커널모드

  메모리 영역이나,파일 영역을 침범하는 경우 등 중요한 정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커널 모드에서만 실행되도록 하여 보안성 확보함

   커널 모드는 운영 체제가 CPU의 제어권을 가지고 운영 체제 코드를 실행하는 모드, 모든 종류 명령 다 실행 가능

- 사용자 모드

   제한적 명령만 실행 가능



사용자 모드 사용 중 프로그램이 프로그램 내에서 중요한 연산을 수행해 버리면 제어가 아무 소용이 없다. 사용자 프로그램이 CPU를 가지고 있는 동안에는 운영 체제가 CPU를 선점할 수 없으므로 사용자 프로그램을 감시할 수 있는 방법이 없기 때문 이를 방지하기 위해 하드웨어적인 지원이 필요함

 컴퓨터 시스템은 CPU내부에 모드 비트를 두어 사용자 프로그램을 감시하게 됨. 모드비트가 0이면 커널모드 1이면 사용자 모드로 제한된 명령만 수행 가능

 CPU는 보안과 관련된 명령 수행하기 전에 모드 비트 조사하며, 사용자 프로그램에게 CPU의 제어권을 넘길 때 모드 비트를 1로 세팅해 넘기게 되어 사용자 프로그램은 보안과 관련된 중요한 명령 수행할 경우에는 시스템 콜을 통해 운영 체제에게 서비스를 대신 해 줄것을 요청하게 된다. 그러면 CPU의 제어권은 다시 운영 체제로 넘어가게 된다.

 인터럽트 발생 시 모드 비트가 자동적으로 0으로 세팅되며, 요청도니 작업이 모두 끝난 후에는 모드 비트 다시 1로 만들어 사용자 프로그램에게 CPU를 넘겨 주게 되는것이다.



## 10. 메모리 보안

 메모리 또한 보안이 필요한데, 이는 여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문

 ex) c언어 포인터 등 잘못 연산해 침범할 경우

 인터럽트 벡터와 인터럽트 처리 루틴이 있는 곳은 각별한 보안이 필요! 운영체제 특권 명령 보안성이 침해되기 때문 이를 위해 두 개 의 레지스터를 사용해서 프로그램이 접근하려는 메모리 부분이 합법인지를 체크함으로써 메모리 보호가 이루어진다.

이 떄 사용되는 두 개의 레지스터는 기준 레지스터, 한계 레지스터 이다.



- 기준 레지스터

   어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관하고 있음

- 한계 레지스터

  그 프로그램이 기준 레지스터 값부터 접근할 수 있는 메모리의 범위를 보관하고 있음

어떤 프로그램이 메모리에 올라가 있는 부분의 시작 주소와 그 프로그램의 길이를 각각 기준 레지스터와 한계레지스터에 보관해 메모리 접근 연산이 있을 때마다 하드웨어 적으로 현재 접근하려는 위치가 합법적인 범위인지를 체크함

 사용자 프로그램은 기준 레지스터 + 한계 레지스터 값 사이읭 주소 영역만 접근이 가능하며, 접근하려는 주소가 이 범위안에 없으면 불법적인 메모리 접근이므로 예외사항 이라는 일종의 소프트웨어적인 인터럽트가 발생하게 됨 이 때 소프트웨어적인 인터럽트를 발생시켜 CPU의 제어권을 해당 프로그램으로부터 운영체제로 이양시키고 운영 체제는 예외 사항을 발생시킨 프로그램을 강제 종료시킨다.



 이때 기준,한계 레지스터를 사용한 메모리 보호 기법은 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치한 경우에만 가능 다른 메모리 기법 등을 추후에 다룸

 메모리 접근 연산은 사용자 프로그램이 CPU를 가지고 있는 경우에도 수행할 수 있는 연산이므로 특권 명령은 아니지만 사용자 프로그램이 메모리를 접근하기 전에 하드웨어적으로 그 접근이 합법적인지를 체크하여 메모리를 보하하게 된다. 이것이 운영 체제맘ㄴ이 수행할 수 있는 입출력 연산과 메모리 접근 연산과으 ㅣ차이점이라고 할 수 있다.



## 11. CPU 보호

특정 프로그램이 CPU를 독점해 무한 반복 등 부적절한 방법으로 CPU의 제어권을 독점한 경우 하나의 프로그램에 CPU가 독점된다. 이를 막기 위해 운영 체제는 타이머라는 하드웨어를 사용한다. 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영 체제에게 CPU의 제어권을 이양시키는 역할을 수행한다.



**타이머**

타이머에 의해 발생되는 인터럽트 처리 루틴 내용은 지금 CPU를 할당받고 수행중인 프로그램에게서 CPU를 선점해 다른 프로그램에게 CPU를 이양하는 내용이다. 타이머가 0이 되는 순간 인터럽트가 발생하며, 타이머는 시분할 시스템에서 혅 ㅐ시간을 계산하기 위해서도 널리 사용된다. 타이머 값을 세팅하는 명령을 로드 타이머라고 하며 이는 특권 명령에 해당된다.



## 12. 시스템 콜을 이용한 입출력 수행

 키보드,디스크 파일로부터 데이터 읽기, 모니터 출력 등 모두 특권 명령인 입출력 명령에 해당하므로 사용자 프로그램이 직접 수행할 수 없다. 사용자 프로그램은 직접 입출력을 수행하는 대신에 운영체제에게 시스템 콜이라는 서비스 대행 요청을 하여 입출력을 수행하게 된다. 시스템 콜은 일종의 소프트웨어적인 인터럽트로서 사용자 프로그램이 시스템 콜을 할 경우 트랩이 발생해 CPU에 대한 제어권이 운영 체제로 넘어가게 된다.  그러면 운영체제는 해당 시스템 콜을 처리하기 위한 루틴으로 가서 정의도니 명령을 수행한다. 