# 4. 인터럽트의 원리



### 4.1 프로그램의 구조와 인터럽트

 프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역(코드, 데이터, 스택 등)이 메모리에 올라가 있어야 한다.

- 코드영역: 작성한 프로그램 함수들이 기계어 명령으로 변환되어 저장되는 부분
- 데이터 영역: 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분
- 스택 영역: 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간



``` 인터럽트와 일반적 프로그램의 함수 호출
인터럽트와 일반적 프로그램의 함수 호출
 일반적으로 프로그램 내에서 발생되는 함수 호출에 필요한 복귀 주소는 각 프로그램의 공간 중 스택 영역에 보관한다.
 인터럽트 때문에 CPU를 선점당한 위치를 저장하기 위한 공간은 운영 체제 커널 부분에 존재하게 된다. (PCB)
 
 Process Control block에는 인터럽트가 발생했을때 그 프로그램의 어느 부분까지 수행했는지를 저장하기 위한 영역이 존재한다.
```







### 4.2 컴퓨터 시스템의 작동 개요

  CPU는 현재 수행해야 할 메모리 주소의 명령을 있는 그대로 처리할 뿐, 이 때, CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터라고 부른다. 즉 CPU는 매번 프로그램 카운터가 가리키는 메모리 영역의 명령을 처리하게 된다.



**입출력 컨트롤러와 로컬 버퍼**

 입출력 장치별로 존재하는 작은 CPU와 메모리를 가각 입출력 컨트롤러와 로컬 버퍼라고 부름



**메모리**

 메모리에는 사용자 프로그램들과 운영 체제가 같이 올라가 수행된다. CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행하게 된다. 

- CPU가 커널 모드에서 수행중
  - 프로그램 카운터가 메모리 주소 중 운영 체제가 존재하는 부분을 가리키고 있다면, 현재 운영 체제의 코드를 수행중
- CPU가 사용자 모드에서 수행중
  - 프로그램 카운터가 사용자 프로그램이 존재하는 메모리 위치를 가리킬 경우



 CPU가 수행하는 명령에는 일반 명령과 특권 명령이 있다. 

- 일반 명령

  메모리에서 자료를 읽어와서 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령, 모든 프로그램이 수행할 수 있는 명령

- 특권 명령

  보안이 필요한 명령으로 입출력장치, 타이머 등 각종 장치를 접근하는 명령, 항상 운영체제만이 수행할 수 있음

 이 두 명령의 실행 가능성을 체크하기 위해 CPU내에 모드비트를 둔다.





### 4.3 프로그램의 실행

 프로그램이 실행된다는 의미는

1. 디스크에 존재하던 실행 파일이 메모리에 적재됨
2. 프로그램이 CPU를 할당받고 기계 명령을 수행하고 있는 상태



실행 파일이 메모리에 적재될 때 프로그램의 주소 공간 중 당장 CPU의 수행에 필요한 부분은 메모리에 올려 놓고 그렇지 않은 부분은 디스크중 메모리의 연장 공간으로 사용되는 스왑 영역에 내려 놓는 방식으로 운영된다.



프로세스 주소 공간은 코드, 데이터, 스택 등으로 구성되며, 각각 프로그램마다 이러한 주소 공간을 별도로 가지며, 각 프로그램마다 독자적으로 존재하는 이와 같은 주소 공간을 우리는 가상 메모리 또는 논리적 메모리라 부른다. 이는 실제 물리적 메모리의 주소와 독립적으로 각 프로그램마다 독자적인 주소 공간을 가지기 때문에 지칭하는 용어이다.



 현재 수행하는 프로그램을 프로세스라고 부른다. 커널의 데이터 영역 중에는 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조인 PCB( 프로세스 제어 블록)을 두고 잇다.



프로그램이 실행되어 자기 자신의 코드 내에서 함수 호출 및 복귀 주소를 유지하기 위해서는 자기 주소 공간 내의 스택을 사용하고, 시스템 콜 등 커널 내의 함수를 호출하는 경우에는 커널의 주소 공간에 존재하는 커널 스택을 사용하게 되는 것이다.



### 4.4 사용자 프로그램이 사용하는 함수

 프로그램이 사용하는 함수는 크게 사용자 정의 함수와 라이브러리 함수, 커널 함수의 세 가지로 구분해 볼 수 있다.

 사용자 정의 함수와 라이브러리 함수는 모두 컴파일하여 실행 파일을 만들게 되면 그 프로그램의 코드 부분에 기계어 명령 형태로 삽입된다. 따라서 이 두 함수는 프로그램이 실행될 때에 해당 프로세스의 주소 공간에 포함된다. 호출 시에도 자신의 주소 공간에 있는 스택을 사용함.

 커널 함수는 사용자 프로그램이 운영 체제의 서비스를 요청하기 위해 호출하는 시스템 콜 함수와, 각종 하드웨어 및 소프트웨어가 CPU의 서비스를 요청하기 위해 발생시키는 인터럽트 처리 함수가 있다. 이와 같은 커널 함수는 운영 체제 커널의 주소 공간에 코드가 정의된다.

 ex) 삼각함수 sin()은 라이브러리 함수고 화면에 문자열을 출력하는 printf()는 그 자체는 라이브러리 함수이지만 궁극적으로 특권 명령인 입출력을 수반하므로 printf 내에서 커널 함수 호출인 시스템 콜을 동반하게 된다.



### 4.5 인터럽트

  CPU는 매번 PC가 가리키고 있는 지점의 명령을 하나씩 수행하고 나서 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지를 체크한다. 세팅 되어 있으면 현재 수행하던 프로세스를 멈추고 인터럽트 처리를 수행함.

CPU 독점을 막기 위해 운영 체제는 타이머 인터럽트를 사용함. 



넓은 의미의 인터럽트는 **하드웨어 인터럽트**와 **트랩** 을 모두 포함하는 개념



**트랩**

트랩이란 소프트웨어가 발생시키는 인터럽트를 말하며, 예외사항과 시스템콜 두 종류가 있음

- 예외사항: 프로그램이 허용되지 않은 연산 수행 시 자동적으로 발생하는 것 ex 0으로 나누는 연산, 주소공간 넘어서는 메모리 참조
- 시스템 콜: 사용자 프로세스가 운영 체제의 서비스를 요청하기 위해 커널의 함수를 호출하는 것



인터럽트와 관련도니 주요 용어에는 인터럽트 벡터와 인터럽트 핸들러가 있다.

- 인터럽트 벡터란 여러가지 인터럽트에 대해 해당 인터럽트 발생시 처리해야 할 루틴의 주소를 보관하고 있는 테이블을 의미 (일종의 함수를 가리키는 포인터라 할 수 있음)

- 인터럽트 핸들러란 실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 부름. 

운영체제 코드 부분에는 각종 인터럽트별로 처리해야 할 내용이 이미 프로그램 되어 있으며 이 부분을 인터럽트 서비스 루틴 또는 인터럽트 핸들러라고 부른다.



### 4.6 시스템 콜

  시스템 콜은 비록 함수 호출이기는 하지만 자신의 주소 공간을 거스르는 영역에 존재하는 함수를 호출하는 것이다. 자신의 프로그램이 아닌 커널이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 일이기 때문

시스템 콜은 주소 공간 자체가 다른 곳으로 이동해야 하므로 일반 함수 호출과는 상이한 방법을 사용함. 그 방법은 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어짐



### 4.7 프로세스의 상태

 프로세스의 상태는 실행, 준비, 봉쇄의 세 가지로 크게 나누어 볼 수 있다.



실행 상태에 있는 프로세스는 매 시점 하나밖에 없다.

봉쇄 상태는 CPUP를 할당받더라도 명령을 수행할 수 없는 프로세스 상태를 말함. ex) 프로세스가 요청한 입출력 작업이 진행중인 경우

준비 상태에 있는 프로세스가 실행 상태로 변경되는 경우는 봉쇄상태가 되거나, 실행 상태에 있던 프로세스의 CPU 할당 시간이 만료되어 타이머 인터럽트가 발생한 경우를 들 수 있음.



운영 체제는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에게 제일 먼저 CPU를 할당한다.

 CPU를 기다리는 프로세스를 중 세우는 준비 큐 외에도 운영 체제는 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 큐를 두고 있다.



### 4.8 프로세스의 두 가지 실행 상태

 하나의 프로세스가 시작되어 수행을 완료하기까지는 프로세스 자신의 주소 공간에 있는 코드만 실행되는 것이 아니라 커널의 주소 공간에 있는 코드도 실행된다. 