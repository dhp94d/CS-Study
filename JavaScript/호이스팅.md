# 호이스팅

> 목표
>
> - 호이스팅이란 무엇인지 이해한다
> - 함수선언문과 함수표현식에서의 호이스팅 차이를 이해한다
>   - let/const와 var변수 선언에서의 호이스팅 예시
> - 같은 이름의 var 변수 선언과 함수 선언에서의 호이스팅에 대해 이해한다.



## 호이스팅의 개념

 함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유표 범위의 최상단에 선언하는 것을 말한다.



### 호이스팅이란

- 자바스크립트 함수는 실행되기 전에 함수 안에 필요한 변수값들을 모두 모아서 유효범위의 최상단에 선언한다.
  - 자바스크립트 파서가 함수 실행 전 해당 함수를 한 번 훑는다.
  - 함수 안에 존재하는 변수/함수 선언에 대한 정보를 기억하고 있다가 실행시킨다.
  - 유효범위: 함수 블록{} 안에서 유효
- 함수 내에서 아래쪽에 존재하는 내용 중 필요한 값들을 끌어올리는 것이다.
  - 실제 코드가 끌어올려지는 건 아니며, 자바스크립트 파서가 내부적으로 끌어올려서 처리하는것
  - 실제 메모리에서는 변화가 없음



### 호이스팅의 대상

- var 변수 선언과 함수선언문에서만 호이스팅이 일어난다.
  - var 변수/함수의 선언만 위로 끌어 올려지며, 할당은 끌어 올려지지 않는다.
  - let/const 변수 선언과 함수표현식에서는 호이스팅이 발생하지 않는다.



ex) var vs let/const 변수

```
console.log("hi")
var a = 'a';
let b = 'b';

// JS Parser 내부의 호이스팅 결과

var a;
console.log("hi");
a = 'a';
let b = 'b';
```



ex) 함수선언문 vs 함수표현식

```
foo();
foo2();
function foo(){
}
var foo2 = function() {
}

//Js parser 내부의 호이스팅 결과

var foo2;
function foo(){
}
foo();
foo2(); //error
foo2 = function() {
}
```

- 호이스팅은 함수 선언문과 함수 표현식에서 서로 다르게 동작하기 때문에 주의해야한다.
  - 변수에 할당된 함수표현식은 끌어 올려지지 않기 때문에 이때는 변수의 스코프 규칙을 그대로 따른다.





### 함수 선언문과 함수 표현식에서의 호이스팅



**함수 선언문**

```
function 함수명(){

}
```



**함수 표현식**

- 변수값에 함수 표현을 담아 놓은 형태
- 함수 표현식은 익명 함수표현식과 기명 함수표현식으로 나눌 수 있다.
  - 일반적으로 함수표현식이라고 부르면 앞에 익명이 생략된 형태로 볼 수 있음
  - 익명 함수표현식: 함수에 식별자가 주어지지 않는다.
  - 기명 함수표현식:함수의 식별자가 존재한다
- 함수표현식의 장점
  - 클로져로 사용
  - 콜백으로 사용(다른 함수의 인자로 넘길 수 있음)

```
var test1 = function() {
	return '익명 함수 표현식'
}

var test2 = function test2(){
	return '기명 함수 표현식';
}
```



**함수 선언문과 함수 표현식의 차이**

- 함수선언문은 호이스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않는다.





**함수 선언문에서의 호이스팅**

- 함수선언문은 코드를 구현한 위치와 관계없이 자바스크립트의 특징인 호이스팅에 따라 브라우저가 자바스크립트를 해석할 때 맨위로 끌어 올려진다.

```
/* 정상 출력 */
function printName(firstname) { // 함수선언문 
    var result = inner(); // "선언 및 할당"
    console.log(typeof inner); // > "function"
    console.log("name is " + result); // > "name is inner value"

    function inner() { // 함수선언문 
        return "inner value";
    }
}

printName(); // 함수 호출 
```

```
/** --- JS Parser 내부의 호이스팅(Hoisting)의 결과 - 위와 동일 --- */
/* 정상 출력 */
function printName(firstname) { 
    var result; // [Hoisting] var 변수 "선언"

    function inner() { // [Hoisting] 함수선언문
        return "inner value";
    }

    result = inner(); // "할당"
    console.log(typeof inner); // > "function"
    console.log("name is " + result); // > "name is inner value"
}

printName(); 
```

- 즉, 해당 예제에서는 함수선언문이 아래에 있어도 printName 함수 내에서 inner를 function으로 인식하기 때문에 오류가 발생하지 않는다.



### 호이스팅 우선순위

같은 이름의 var 변수 선언과 함수 선언에서의 호이스팅

- 변수 선언이 함수 선언보다 위로 끌어올려진다.

```
 var myName = "hi";

  function myName() {
      console.log("yuddomack");
  }
  function yourName() {
      console.log("everyone");
  }

  var yourName = "bye";

  console.log(typeof myName);
  console.log(typeof yourName);
```

```
** --- JS Parser 내부의 호이스팅(Hoisting)의 결과 --- */
  // 1. [Hoisting] 변수값 선언 
  var myName; 
  var yourName; 

  // 2. [Hoisting] 함수선언문
  function myName() {
      console.log("yuddomack");
  }
  function yourName() {
      console.log("everyone");
  }

  // 3. 변수값 할당
  myName = "hi";
  yourName = "bye";

  console.log(typeof myName); // > "string"
  console.log(typeof yourName); // > "string"
```



- 값이 할당되어 있지 않은 변수와 값이 할당되어 있는 변수에서의 호이스팅

```
  var myName = "Heee"; // 값 할당 
  var yourName; // 값 할당 X

  function myName() { // 같은 이름의 함수 선언
      console.log("myName Function");
  }
  function yourName() { // 같은 이름의 함수 선언
      console.log("yourName Function");
  }

  console.log(typeof myName); // > "string"
  console.log(typeof yourName); // > "function"
```





tip.

- 코드의 가독성과 유지보수를 위해 호이스팅이 일어나지 않도록 한다.



참조: https://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.html