# 프로토타입

 자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 "모든 것"이 객체입니다. 원시 타입의 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체입니다.



## 상속과 프토로타입

상속은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말합니다.

자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거합니다.(기존의 코드를 재사용)



**생성자 함수**는 동일한 프로퍼티 구조를 갖는 객체를 여러 개 생성할 때 유용합니다.

```
function Circle(){
	this.getArea = function(){
	
	}
}
```

>  생성자 함수를 상속받아 똑같은 메서드가 중복 생성



 위의 구조의 생성자 함수에는 문제가 있는데 인스턴스를 생성할 때마다 getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유한다는 점입니다. 이와 같은 경우는 모든 인스턴스가 동일한 메서드를 중복 소유하는 것으로 메모리를 불필요하게 낭비하며 인스턴스를 생성할 때마다 메서드를 생성하므로 퍼포먼스에도 악영향을 줍니다.



**상속을 통해 불필요한 중복을 제거해 보자. **(자바스크립트는 프로토타입을 기반으로 상속을 구현합니다)

```
Circle.prototype.getArea = function() {

}
```

> 프로토타입 객체를 상속받아 중복생성 제거

이 경우 getArea 메서드는 단 하나만 생성되어 프로토타입인 Circle.prototype의 메서드로 할당되어 있습니다.



## 프로토타입 객체

 상속을 구현하기 위해서 사용

프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공합니다.

모든 객체는 [[Prototype]]이라는 내부 슬롯을 가집니다



### \__proto__ 접근자 프로퍼티

 모든 객체는 \__proto__ 접근자 프로퍼티를 통해 자신의 프로토타입 즉 [[Prototpye]] 내부 슬롯에 간접적으로 접근할 수 있습니다.

접근자 프로퍼티는 자체적으로 [[Value]] 프로퍼티를 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수([[Get]], [[Set]]) 프로퍼티 어트리뷰트로 구성된 프로퍼티입니다. 이 두가지 접근자함수를 이용하여 프로토타입을 취득하거나 할당합니다.

\__proto__ 접근자 프로퍼티를 통해  프로토타입에 접근하면 내부적으로 \___proto__ 접근자 프로퍼티의 getter함수인 [[Get]] 이 호출됩니다. 새롭게 할당하면 setter함수인 [[Set]]이 호출됩니다.

```
obj.__proto_;
obj.__proto__ == parent
```



모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여있으며, 자바스크립트 엔진은 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 \__proto__ 접근자 프로퍼티가 가리키는 참조를 따라자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검사합니다 최상위 객체는 Object_prototype입니다.



**\__proto__ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유**

상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함! 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 하기 떄문! 허나 접근자 프로퍼티를 코드 내에서 직접 사용하는것은 권장하지 않습니다



### 함수 객체의 prototype 프로퍼티

함수 객체만이 소유하는 prototype 프로퍼티는 생성잫 ㅏㅁ수가 생성할 인스턴스의 프로토타입을 가리킵니다.

![image](https://user-images.githubusercontent.com/68668924/106238563-695e0680-6244-11eb-8c1d-8887719c0733.png) 



### instanceof 연산자

instanceof 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받습니다. 우변의 피연산자가 함수가 아닌 경우 타입 에러가 발생합니다

```
객체 instanceof 생성자 함수
```

우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true로 평가되고 그렇지 않은 경우에는 false로 평가됩니다.



### 직접 상속

**Object.create에 의한 직접 상속**

 Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성합니다. Object.create 메서드도 다른 객체 생성 방식과 마찬가지로 추상 연산 OrdinaryObjectCreate를 호출합니다.

이 메서드의 첫 번째 매개변수에는 생성ㅇ할 객체의 프로토타입을 지정할 객체를 전달하고, 두번째 매개변수에는 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이뤄진 객체를 전달합니다. 두 번째 인수는 옵션이므로 생략 가능합니다

![image](https://user-images.githubusercontent.com/68668924/106239199-8b0bbd80-6245-11eb-8f43-73c7435bc1ec.png)



이 처럼 Object.create 메서드는 첫 번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성합니다. 즉 객체를 생성하면서 직접적으로 상속을 구현하는 것입니다.

**장점**

- new 연산자가 없이도 객체를 생성 가능
- 프로토타입을 지정하면서 객체를 생성 가능
- 객체 리터럴에 의해 생성된 객체도 상속받을 수 있음





### for in 

for in은 어트리뷰트 [[Enumerable]]의 true인 프로퍼티를 순회하며 열거합니다