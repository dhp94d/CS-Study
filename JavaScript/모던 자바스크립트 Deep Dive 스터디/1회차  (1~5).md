# 모던 자바스크립트 Deep Dive 스터디 1일차 (1~5)

목차

1. 프로그래밍
2. 자바스크립트란?
3. 자바스크립트 개발 환경과 실행 방법
4. 변수 ★
5. 표현식과 문 ★



## 1 . 프로그래밍



**1.1  프로그래밍이란 무엇일까?**

 0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 정확하고 상세하게 요구사항을 설명하는 작업입니다. 즉 문제 해결 방안을 고려할 떄 컴퓨터의 입장에서 바라봐야 하며, 이때 필요한 것이 컴퓨팅 사고 입니다.



**1.2 프로그래밍 언어**

컴퓨터와의 대화에 사용되는 일종의 표현 수단으로써, 사람과 컴퓨터 모두가 이해할 수 있는 약속된 형태의 인공어



## 2. 자바스크립트란?



**2.1 자바스크립트의 탄생**

 1995년 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어로 탄생

모카 -> 라이브스크립트 -> 자바스크립트로 이름이 최종 명명

이렇게 탄생한 자바스크립트는 현재 모든 브라우저의 표준 프로그래밍 언어로 자리잡음



**2.2 자바스크립트의 표준화**

 자바스크립트의 파생 버전들이 탄생하며 브라우저에 따라 웹페이지가 정삭적을 동작하지 않는 **크로스 브라우징 이슈** 가 발생하기 시작! 

=> 모든 브라우저에서 정삭적으로 동작하는 웹페이지 개발이 무척 어려워짐

이에 자바스크립트의 파편화를 방지하고, 모든 브라우저에서 정상적으로 동작하는 표준화된 자바스크립트가 탄생 상표권의 문제로 **ECMAScript**로 명명



**2.3 자바스크립트의 역사**

 초창기 자바스크립트는 웹페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 사용되었으며, 이 시기에 대부분의 로직은 주로 웹 서버에서 실행 되었습니다. 즉 브라우저는 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링하는 수준이였습니다.



- **Ajax의 등장**

  1999년 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능인 Ajax가 XMLHttpRequest라는 이름으로 등장

   이전의 웹 페이지는 html태그로 시작해서 html 태그로 끝나는 완전한 HTML 코드를 서버로부터 전송받아 웹페이지 전체를 렌더링하는 방식으로 동작했습니다. 즉 화면이 전환되면 서버로부터 새로운 HTML을 전송받아 웹페이지 전체를 처음부터 다시 렌더링 했습니다.

   이러한 방식의 단점으로 변경할 필요가 없는 HTML 부분까지 포함된 HTML 코드를 서버로부터 다시 전송받기 때문에 성능적으로 좋지않고, 화면이 전환되면서 순간적으로 깜빡이는 현상이 발생하였습니다.

  Ajax의 등장으로 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고 서버로부터 필요한 데이터만 전송받아 변경해야하는 부분만 한정적으로 렌더링하는 방식이 가능해 졌습니다.

  

- **V8 자바스크립트 엔진**

   구글의 V8 자바스크립트 엔진으로 촉발된 자바스크립트의 발전으로 과거 웹 서버에서 수행되던 로직들이 대거 클라이언트(브라우저)로 이동했고, 이는 웹 애플리케이션 개발에서 프런트엔드 영역이 주목받는 계기로 작용되었습니다.



- **Node.js**

   Node.js는 구글 V8엔진으로 빌드된 자바스크립트 런타임 환경입니다.

  Node.js는 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경입니다.

  Node.js는 비동기 I/O를 지원하며 단일 스레드 이벤트루프 기반으로 동작함으로써 요청 처리 성능이 좋습니다.  즉 데이터를 실시간으로 처리하기 위해 I/O가 빈번하게 발생하는 SPA에 적합합니다. 하지만 CPU 사용률이 높은 애플리케이션에는 권장하지 않습니다.



**2.4 자바스크립트 특징**

 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언어**이다. 대부분의 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점을 해결했다.

인터프리터는 소스코드를 즉시 실행하고, 컴파일러는 빠르게 동작하는 머신 코드를 생성하고  최적화한다.

자바스크립트는 런타임에 컴파일되며 실행파일이 생성되지 않고 인터프리터의 도움 없이 실행할 수 없기 때문에 컴파일러 언어라고 할 수 는 없음.

자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 언어





## 3. 자바스크립트 개발 환경과 실행 방법

![image-20210316101511550](C:\Users\dw115\AppData\Roaming\Typora\typora-user-images\image-20210316101511550.png) 



## 4. 변수



**4.1 변수란?**

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말합니다. 즉 값의 위치를 가리키는 상징적인 이름



**4.3 변수 선언**

변수를 사용하려면 반드시 선언이 필요하며, 자바스크립트는 변수를 선언할 때 var, let, const를 사용합니다.

```
변수 선언?
 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는것, 변수 선언에 의해 확보된 메모리 공간을 확보가 해제되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용 가능하다.
```



예시) var 로 score 선언 시
`var score;`

변수를 선언한 이후 아직 변수에 값을 할당하지 않았으나 변수 선언에 의해 확보된 메모리 공간은 자바스크립트 엔진에 의해 **undefined** 라는 값이 암묵적으로 할당되어 초기화됨.  => var키워드 사용한 변수 선언은 초기화 단계를 통해 암묵적으로 undefined를 할당해 초기화함. (쓰레기 값이 나오는것을 방지해줌)

 자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행함

- 선언단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화 한다.

```변수 이름은 어디에 등록되는가?
변수 이름은 어디에 등록될까?
 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 실행컨텍스트는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다. 이 때 변수 이름과 변수 값은 실행 컨텍스트 안에 key/value 형태인 객체로 등록되어 관리됨.
```



변수 사용시 선언을 안하면 ReferenceError 에러 발생.



**4.4 변수 선언의 실행 시점과 변수 호이스팅**

```
console.log(score);
var score;
```

위의 예제를 살펴보자.

 자바스크립트 코드는 인터프리터에 의해 한줄씩 순차적으로 실행되므로 console.log(score);가 가장 먼저 실행되어 참조에러가 발생될 것 같지만 참조에러가 발생되지 않고 undefined가 출력된다.

그 이유는 변수 선언이 소스코드가 한 줄씩 실행되는 시점. 즉 **런타임이 아니라 그 이전 단계**에서 먼저 실행되기 때문이다.



**변수 호이스팅이란 무엇일까?**

 자바스크립트 엔진은 인터프리터에 의해 한 줄씩 순차적으로 실행하기 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다. 이 평가 과정에서 자바스크립트 엔진은 **변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)**을 소스코드에서 찾아내 먼저 실행한다 그리고 소스코드 평가 과정이 끝나면 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.

=> 자바스크립트 엔진은 변수 선언이 소스코드 어디에 있든 상관없이 가장 먼저 실행, 따라서 변수 선언이 소스코드 어디에 위치하든 상관 없으며, 변수선언이 런타임 이전 단계에서 먼저 실행되어 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유 특징을 **변수 호이스팅** 이라고 한다.



  

**4.5 값의 할당**

자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다

`var score = 80`

변수 선언과 값의 할당의 실행 시점은 다르며, **변수 선언**은 런타임 이전에 **값의 할당**은 런타임에 실행된다.



![image-20210317195212194](C:\Users\dw115\AppData\Roaming\Typora\typora-user-images\image-20210317195212194.png) 

위의 그림과 같이 값을 할당할때는 이전 값이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그곳에 할당 값80을 저장한다.



**4.6 값의 재할당**

값을 재할당 시 새로운 메모리 공간을 확보하고 그곳에 값을 할당하기 때문에 그 이전의 메모리 공간들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다.(단 메모리에서 언제 해제될지는 예측할 수 없음)

```가비지 콜렉터
가비지 콜렉터란?
 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말함. 여기서 더 이상 사용되지 않는 메모리란 어떤 식별자도 참조하지 않는 메모리 공간을 의미! 
 자바스크립트는 이 가비지 콜렉터를 이용하여 메모리 누수를 방지 => 매니지드언어(메모리 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하여 개발자의 직접적인 메모리 제어 허용X)
```



**4.7 네이밍**

변수나 함수의 이름은 카멜케이스!

생성자 함수, 클래스 이름에는 파스칼 케이스 사용!





## 5. 표현식과 문



### 5.1 값

값은 식(표현식)이 평가되어 생성된 결과를 말한다.

ex)10 + 20의 식은 평가되어 숫자 값 30을 생성



### 5.2 리터럴

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말함. => 값을 생성하기 위해 미리 약속한 표기법

![image-20210317195857380](C:\Users\dw115\AppData\Roaming\Typora\typora-user-images\image-20210317195857380.png) 



### 5.3 표현식

표현식은 값으로 평가될 수 있는 문이다. 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.



### 5.4 문

문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 문의 집합으로 이루어진 것이 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.

문은 여러 토큰으로 구성되며, 여기서 토큰이랑 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다. 문을 명령문이라고 부르기도함.

![image-20210317200140348](C:\Users\dw115\AppData\Roaming\Typora\typora-user-images\image-20210317200140348.png) 

### 5.5 세미콜론과 세미콜론 자동 삽입기능

세미콜론은 문의 종료를 나타내며, 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행합니다.

```
코드블록({ ...}) 뒤 세미콜론을 붙이지 않는 이유는 이러한 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성을 같기 때문입니다.
```



**세미클론은 생략이 가능합니다.** 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미클론을 자동으로 붙여주는 세미클론 자동 삽입기능이 암묵적으로 수행되기 떄문입니다.



### 5.6 표현식인 문과 표현식이 아닌 문

![image-20210317200507075](C:\Users\dw115\AppData\Roaming\Typora\typora-user-images\image-20210317200507075.png) 

구분하는 방법은 변수에 할당해 보는것, 표현식인 문은 값으로 평가되므로 변수에 할당할 수 있고, 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생한다.



크롬 개발자 도구에서는 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. 이를 완료값이라 하는데, 완료값은 표현식의 평가 결과가 아니다. 따라서 다른 값과 같이 변수에 할당할 수 없고 참조할 수 도 없다.